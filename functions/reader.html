<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Reader</title>
<style>
body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background-color: #f4f4f4;
    color: #333;
}

h1 {
    color: #0056b3;
}

.controls {
    margin-bottom: 20px;
    padding: 15px;
    background-color: #e0e0e0;
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
}

.controls label, .controls select, .controls button {
    margin-right: 10px;
}

button, select {
    padding: 8px 15px;
    border: 1px solid #ccc;
    border-radius: 5px;
    cursor: pointer;
    background-color: #fff;
    transition: background-color 0.2s;
}

button:hover {
    background-color: #ddd;
}

#playPauseBtn {
    background-color: #007bff;
    color: white;
    border-color: #007bff;
}

#playPauseBtn:hover {
    background-color: #0056b3;
}

.reader-container {
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 20px;
    max-height: 600px; /* Limit height for scrollability */
    overflow-y: auto;
    font-size: 1.1em;
    line-height: 1.6;
    white-space: pre-wrap; /* Preserves whitespace and wraps lines */
    word-wrap: break-word; /* Breaks long words */
}

.reader-container p {
    margin: 0; /* Remove default paragraph margins */
    padding: 2px 0; /* Small vertical padding for clickable areas */
    cursor: pointer;
}

.reader-container p:hover {
    background-color: #e6f7ff; /* Light blue on hover */
}

.current-line {
    background-color: #d1ecf1; /* Highlight current line */
    font-weight: bold;
    border-left: 5px solid #007bff;
    padding-left: 5px;
}

.placeholder-text {
    color: #888;
    text-align: center;
    font-style: italic;
    padding: 50px;
}

/* Screen reader only class */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    margin: -1px;
    padding: 0;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
}

</style>
</head>
<body>
    <h1>Simple Text Reader</h1>

    <div class="controls">
        <label for="fileInput">Choose a .txt file:</label>
        <input type="file" id="fileInput" accept=".txt">

        <label for="speedSelect">Reading Speed:</label>
        <select id="speedSelect">
            <option value="0.75">Slow</option>
            <option value="1.0" selected>Normal</option>
            <option value="1.25">Fast</option>
            <option value="1.5">Faster</option>
            <option value="2.0">Very Fast</option>
        </select>

        <button id="playPauseBtn">Play</button>
        <button id="prevLineBtn">Previous Line</button>
        <button id="nextLineBtn">Next Line</button>
        <button id="bookmarkBtn">Bookmark Current Line</button>
        <select id="bookmarksSelect" style="display:none;">
            <option value="">Jump to Bookmark</option>
        </select>
    </div>

    <div class="reader-container">
        <div id="textDisplay" role="document" aria-labelledby="readerTitle">
            <h2 id="readerTitle" class="sr-only">Document Content</h2>
            <p class="placeholder-text">Load a .txt file to start reading.</p>
        </div>
    </div>

    <div id="liveRegion" aria-live="polite" aria-atomic="true" class="sr-only">
        </div>

    <script>
document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('fileInput');
    const textDisplay = document.getElementById('textDisplay');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const prevLineBtn = document.getElementById('prevLineBtn');
    const nextLineBtn = document.getElementById('nextLineBtn');
    const speedSelect = document.getElementById('speedSelect'); // Retain for potential future use or interval adjustment
    const bookmarkBtn = document.getElementById('bookmarkBtn');
    const bookmarksSelect = document.getElementById('bookmarksSelect');
    const liveRegion = document.getElementById('liveRegion'); // The ARIA live region

    let lines = [];
    let currentLineIndex = 0;
    let playingInterval = null; // Renamed from speakingInterval
    let isPlaying = false;
    let currentFileName = '';

    // --- Core Reading Functionality (managing live region and highlighting) ---

    function announceLineInLiveRegion(lineText) {
        liveRegion.textContent = lineText;
    }

    function highlightCurrentLine() {
        // Remove highlight from previous line
        const prevHighlighted = textDisplay.querySelector('.current-line');
        if (prevHighlighted) {
            prevHighlighted.classList.remove('current-line');
        }

        // Add highlight to current line
        const currentLineElement = textDisplay.children[currentLineIndex];
        if (currentLineElement) {
            currentLineElement.classList.add('current-line');
            // Scroll into view if not visible
            currentLineElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }

    function readNextLine() {
        if (currentLineIndex < lines.length) {
            highlightCurrentLine();
            announceLineInLiveRegion(lines[currentLineIndex]);
            currentLineIndex++;
        } else {
            // End of file
            stopReading();
            announceLineInLiveRegion("End of file reached.");
        }
    }

    function startReading() {
        if (lines.length === 0) return; // No file loaded

        isPlaying = true;
        playPauseBtn.textContent = 'Pause';

        // Read the current line immediately when "Play" is pressed
        // If currentLineIndex is at end, restart from beginning for play button
        if (currentLineIndex >= lines.length) {
            currentLineIndex = 0;
        }
        readNextLine();

        // Calculate interval based on selected speed (rough estimate)
        // Adjust this value based on perceived reading speed.
        // The speedSelect value of 1.0 could be ~200ms per word or similar.
        const baseDelayMs = 3000; // Base delay for 'Normal' speed (1.0)
        const selectedSpeed = parseFloat(speedSelect.value);
        const intervalDelay = baseDelayMs / selectedSpeed;

        playingInterval = setInterval(readNextLine, intervalDelay);
    }

    function stopReading() {
        isPlaying = false;
        playPauseBtn.textContent = 'Play';
        if (playingInterval) {
            clearInterval(playingInterval);
            playingInterval = null;
        }
        // Keep highlight on the last read line, but don't clear it.
        // It will be cleared when a new line is highlighted.
    }

    // --- Event Listeners ---

    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const textContent = e.target.result;
                lines = textContent.split('\n');
                currentFileName = file.name;

                textDisplay.innerHTML = ''; // Clear previous content
                if (lines.length === 0 || (lines.length === 1 && lines[0].trim() === '')) {
                     const p = document.createElement('p');
                     p.textContent = "File is empty.";
                     p.classList.add('placeholder-text');
                     textDisplay.appendChild(p);
                     lines = []; // Ensure lines array is truly empty if file is empty
                } else {
                    lines.forEach((line, index) => {
                        const p = document.createElement('p');
                        p.textContent = line.trim() === '' ? '\u00A0' : line; // Non-breaking space for empty lines
                        p.dataset.lineIndex = index; // Store index
                        p.addEventListener('click', () => {
                            stopReading(); // Stop automatic playback
                            currentLineIndex = index; // Set current line to clicked line
                            highlightCurrentLine();
                            announceLineInLiveRegion(lines[currentLineIndex]);
                        });
                        textDisplay.appendChild(p);
                    });
                }


                currentLineIndex = 0; // Reset to start of file
                stopReading(); // Ensure playback is stopped
                playPauseBtn.disabled = (lines.length === 0);
                prevLineBtn.disabled = (lines.length === 0);
                nextLineBtn.disabled = (lines.length === 0);
                bookmarkBtn.disabled = (lines.length === 0);
                loadBookmarks(); // Load bookmarks for the new file
                announceLineInLiveRegion(`File "${file.name}" loaded. ${lines.length} lines.`);
            };
            reader.readAsText(file);
        }
    });

    playPauseBtn.addEventListener('click', () => {
        if (isPlaying) {
            stopReading();
            announceLineInLiveRegion("Reading paused.");
        } else {
            startReading();
            announceLineInLiveRegion("Reading started.");
        }
    });

    prevLineBtn.addEventListener('click', () => {
        stopReading();
        // Go back two steps so next readNextLine advances to the previous logical line
        currentLineIndex = Math.max(0, currentLineIndex - 2);
        highlightCurrentLine();
        announceLineInLiveRegion(lines[currentLineIndex]);
    });

    nextLineBtn.addEventListener('click', () => {
        stopReading();
        readNextLine();
    });

    // Speed select will now only affect the interval of the JavaScript playback
    speedSelect.addEventListener('change', () => {
        if (isPlaying) {
            stopReading(); // Restart to apply new speed immediately
            startReading();
        }
    });

    // --- Bookmark Functionality ---

    function saveBookmark(lineIndex) {
        if (!currentFileName || lineIndex === undefined) return;

        let bookmarks = JSON.parse(localStorage.getItem('textReaderBookmarks')) || {};
        if (!bookmarks[currentFileName]) {
            bookmarks[currentFileName] = [];
        }

        if (!bookmarks[currentFileName].includes(lineIndex)) {
            bookmarks[currentFileName].push(lineIndex);
            bookmarks[currentFileName].sort((a, b) => a - b);
        }
        localStorage.setItem('textReaderBookmarks', JSON.stringify(bookmarks));
        populateBookmarksDropdown();
        announceLineInLiveRegion(`Bookmark saved for line ${lineIndex + 1}.`);
    }

    function loadBookmarks() {
        bookmarksSelect.innerHTML = '<option value="">Jump to Bookmark</option>';
        if (!currentFileName) {
            bookmarksSelect.style.display = 'none';
            return;
        }

        let bookmarks = JSON.parse(localStorage.getItem('textReaderBookmarks')) || {};
        const fileBookmarks = bookmarks[currentFileName] || [];

        if (fileBookmarks.length > 0) {
            fileBookmarks.forEach(index => {
                if (index < lines.length) { // Ensure bookmark is still valid for current file
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Line ${index + 1}: ${lines[index].substring(0, 50).trim()}...`;
                    bookmarksSelect.appendChild(option);
                }
            });
            bookmarksSelect.style.display = 'inline-block';
        } else {
            bookmarksSelect.style.display = 'none';
        }
    }

    function populateBookmarksDropdown() {
        loadBookmarks();
    }

    bookmarkBtn.addEventListener('click', () => {
        if (lines.length === 0) return;
        // If playing, bookmark the *current* line (which is `currentLineIndex - 1` because readNextLine increments after speaking)
        // If paused, bookmark the highlighted line (which is `currentLineIndex`).
        let lineToBookmark = isPlaying && currentLineIndex > 0 ? currentLineIndex - 1 : currentLineIndex;
        lineToBookmark = Math.min(lineToBookmark, lines.length - 1); // Ensure it's not past last line

        if (lines.length > 0 && lineToBookmark >= 0) {
            saveBookmark(lineToBookmark);
        }
    });

    bookmarksSelect.addEventListener('change', (event) => {
        const selectedIndex = parseInt(event.target.value, 10);
        if (!isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < lines.length) {
            stopReading();
            currentLineIndex = selectedIndex;
            highlightCurrentLine();
            announceLineInLiveRegion(lines[currentLineIndex]);
        }
        bookmarksSelect.value = ""; // Reset dropdown after selection
    });

    // --- Initial State ---
    playPauseBtn.disabled = true;
    prevLineBtn.disabled = true;
    nextLineBtn.disabled = true;
    bookmarkBtn.disabled = true;
    loadBookmarks(); // Attempt to load any existing bookmarks on page load
});
</script>
</body>
</html>
